import { TestSession } from "@peerbit/test-utils";
import {
    Canvas,
    getImmediateRepliesQuery,
    getRepliesQuery,
    getOwnedElementsQuery,
    Element,
    StaticContent,
    Layout,
    getTextElementsQuery,
    getImagesQuery,
    LOWEST_QUALITY,
    ChildVisualization,
    LinkPlacement,
    Scope,
    diffCanvases,
    loadCanvasFromScopes,
    IndexableCanvas,
} from "../content.js";
import { SearchRequest, Sort, SortDirection } from "@peerbit/document";
import { expect } from "chai";
import { delay, waitForResolved } from "@peerbit/time";
import { equals, sha256Sync } from "@peerbit/crypto";
import { StaticImage } from "../static/image.js";
import { Peerbit } from "peerbit";
import { createRoot } from "../root.js";
import { deserialize, serialize } from "@dao-xyz/borsh";
import { get } from "http";

describe("canvas", () => {
    let session: TestSession;

    beforeEach(async () => {
        session = await TestSession.connected(2);
    });

    afterEach(async () => {
        await session.stop();
    });

    const checkContent = async (canvas: Canvas, content: string) => {
        const elements = await canvas.elements.index
            .iterate({ query: getOwnedElementsQuery(canvas) })
            .all();
        expect(elements).to.have.length(1);
        expect(elements[0].__indexed.content).to.eq(content);
    };

    const getCheckOneReply = async (canvas: Canvas) => {
        const children = await canvas.replies.index
            .iterate({ query: getImmediateRepliesQuery(canvas) })
            .all();
        expect(children).to.have.length(1);
        return children[0];
    };

    const checkCountAllReplies = async (canvas: Canvas, number: number) => {
        const children = await canvas.replies.index
            .iterate({ query: getRepliesQuery(canvas) })
            .all();
        expect(children).to.have.length(number);
    };

    const checkCountImmediateReplies = async (
        canvas: Canvas,
        number: number
    ) => {
        const children = await canvas.replies.index
            .iterate({ query: getImmediateRepliesQuery(canvas) })
            .all();
        expect(children).to.have.length(number);
    };

    const createOpenRootScope = (args?: { seed?: Uint8Array | number[] | Scope, replicate?: boolean, replicas?: { min?: number } }) => {
        return session.peers[0].open(
            args?.seed instanceof Scope ? args?.seed : new Scope({
                seed: args?.seed ? new Uint8Array(args?.seed) : undefined,
                publicKey: session.peers[0].identity.publicKey,
            }),
            {
                args: {
                    replicate: args?.replicate ?? true,
                    replicas: args?.replicas ?? undefined
                }
            }
        );
    };

    describe('loadCanvasFromScopes', () => {
        it('can load from replies', async () => {
            const rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                seed: new Uint8Array(),
                selfScope: rootScope,
            }));


            const [a] = await root.getCreateCanvasByPath(["a"]);
            expect(a).to.exist;
            const aAgain = await loadCanvasFromScopes(a.id, [rootScope]);
            expect(aAgain?.idString).to.eq(a.idString);
        })
    })

    it("can open multiple referencing same scope", async () => {
        const rootScope = await createOpenRootScope()
        const [_, root] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            seed: new Uint8Array(),
            selfScope: rootScope,
        }));

        const [__, root2] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            seed: new Uint8Array(),
            selfScope: rootScope,
        }));

    });

    it("can add and delete", async () => {
        await session.stop();

        let directory = "./tmp/can reload subpath only/" + +new Date();
        session = await TestSession.connected(1, { directory });

        const rootScope = await createOpenRootScope()
        const [_, root] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            seed: new Uint8Array(),
            selfScope: rootScope,
        }));


        const [a, b, c] = await root.getCreateCanvasByPath(["a", "b", "c"]);

        const rootImmediaetReplies = await root.countReplies({ onlyImmediate: true });
        expect(Number(rootImmediaetReplies)).to.eq(1); // a has one reply (b)
        const rootTotalReplies = await root.countReplies({ onlyImmediate: false });
        expect(Number(rootTotalReplies)).to.eq(3); // a has two replies (b and c)


        const aImmediaetReplies = await a.countReplies({ onlyImmediate: true });
        expect(Number(aImmediaetReplies)).to.eq(1); // a has one reply (b)
        const aTotalReplies = await a.countReplies({ onlyImmediate: false });
        expect(Number(aTotalReplies)).to.eq(2); // a has two replies (b and c)

        const bImmediaetReplies = await b.countReplies({ onlyImmediate: true });
        const bTotalReplies = await b.countReplies({ onlyImmediate: false });

        expect(Number(bImmediaetReplies)).to.eq(1); // b has one reply (c)
        expect(Number(bTotalReplies)).to.eq(1); // b has one reply (c)




        await waitForResolved(async () => { // indexer async 
            const all = await root.replies.index.iterate({
                query: getRepliesQuery(root),
                sort: new Sort({
                    key: "replies",
                    direction: SortDirection.ASC,
                }),
            }).all();
            expect(all).to.have.length(3); // root + a + b + c
            expect(all.map(x => Number(x.__indexed.replies))).to.be.deep.eq([0, 1, 2])
            expect(all.map(x => x.__indexed.context)).to.deep.eq(["c", "b", "a"]);
            expect(a.path[0].path).to.have.length(1); // a is the first post in the root
            expect(b.path[0].path).to.have.length(2); // b is the second post in the root
            expect(c.path[0].path).to.have.length(3); // c is the third post in the root
            expect(await a.nearestUpScope.replies.index.iterate({ query: getImmediateRepliesQuery(a) }).all()).to.have.length(1); // a has one reply (b)
            expect(await b.nearestUpScope.replies.index.iterate({ query: getImmediateRepliesQuery(b) }).all()).to.have.length(1); // b has one reply (c)
        })

        const checkData = async (empty?: boolean) => {
            const allReplies = await root.replies.index.iterate().all();
            expect(allReplies).to.have.length(empty ? 1 : 4);

            const allElements = await root.elements.index.iterate().all();
            expect(allElements).to.have.length(empty ? 0 : 3);
        };
        await checkData();
        await root.remove(a);

        await checkData(true);

        await session.peers[0].stop(); // close the peer to make sure the data is deleted


        session = await TestSession.connected(1, { directory });
        const peer = session.peers[0];
        const rootAgain = await peer.open(rootScope, {
            existing: "reuse",
            args: {
                replicate: true,
            },
        });

        expect(rootAgain).to.exist;

        const allRepliesAfterReload = await rootAgain.replies.index
            .iterate({ query: {} })
            .all();

        expect(allRepliesAfterReload).to.have.length(1); // the root itself
    });

    it("can delete from muliple scopes", async () => {
        const rootScope = await createOpenRootScope()
        const [_, rootA] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            seed: new Uint8Array(),
            selfScope: rootScope
        }));

        const anotherScope = await createOpenRootScope({ seed: new Uint8Array([2]) })
        const [__, rootB] = await anotherScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            seed: new Uint8Array([1]),
            selfScope: anotherScope,
        }));


        expect(rootA.idString).to.not.eq(rootB.idString);

        /*       await rootA.load();
              await rootB.load();
       */

        const [created, reply] = await rootA.createReply(
            new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                seed: new Uint8Array([3]),
                parent: rootA,
            }),
            {
                layout: new Layout({
                    x: 0,
                }),
                type: ChildVisualization.OUTLINE,
            }
        );

        await reply.addTextElement("Hello world");

        expect(await rootA.replies.index.get(reply.id)).to.exist;
        expect(await rootA.links.index.getSize()).to.eq(1);
        expect(await rootA.elements.index.getSize()).to.eq(1);
        const l = await rootB.replies.index.get(reply.id);
        expect(await rootB.replies.index.get(reply.id)).to.be.undefined;
        expect(await rootB.links.index.getSize()).to.eq(0);
        expect(await rootB.elements.index.getSize()).to.eq(0);

        expect(created).to.be.true;
        const clone = await reply.cloneInto(rootB);

        expect(await rootB.replies.index.get(clone.id)).to.exist;
        expect(await rootB.links.index.getSize()).to.eq(1);
        expect(await rootB.elements.index.getSize()).to.eq(1);

        await rootA.remove(reply);
        expect(await rootA.replies.index.get(reply.id)).to.be.undefined;
        expect(await rootA.links.index.getSize()).to.eq(0);
        expect(await rootA.elements.index.getSize()).to.eq(0);

        expect(await rootB.replies.index.get(clone.id)).to.exist;
        expect(await rootB.links.index.getSize()).to.eq(1);
        expect(await rootB.elements.index.getSize()).to.eq(1);

        await rootB.remove(clone);
        expect(await rootB.replies.index.get(clone.id)).to.be.undefined;
        expect(await rootB.links.index.getSize()).to.eq(0);
        expect(await rootB.elements.index.getSize()).to.eq(0);
    });

    it("can make path", async () => {
        const rootScope = await createOpenRootScope()
        const [_, root] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            seed: new Uint8Array(),
            selfScope: rootScope,
        }));

        const [_a, _b, c] = await root.getCreateCanvasByPath(["a", "b", "c"]);
        expect(equals(_b.lastPathCanvas, _a.id)).to.be.true;

        expect(root.replies.log.log.length).to.eq(4);

        expect(await c.createContext()).to.eq("c");
        expect((await c.loadPath({ includeSelf: true })).length).to.eq(4);

        expect((await c.loadPath({ includeSelf: true }))[3]).to.eq(c);

        const [__a, __b, d] = await root.getCreateCanvasByPath(["a", "b", "d"]);
        expect(__a.idString).to.eq(_a.idString)
        expect(equals(__b.lastPathCanvas, __a.id)).to.be.true

        expect(root.replies.log.log.length).to.eq(5);

        expect(await d.createContext()).to.eq("d");
        expect((await d.loadPath({ includeSelf: true })).length).to.eq(4);

        expect((await d.loadPath({ includeSelf: true }))[3]).to.eq(d);

        const childrenFromRoot = await root.replies.index.index
            .iterate({ query: getImmediateRepliesQuery(root) })
            .all();
        expect(childrenFromRoot).to.have.length(1); // both paths start at "a"

        const ab = await root.findCanvasesByPath(["a", "b"]);
        expect(
            await Promise.all(ab.canvases.map((x) => x.createContext()))
        ).to.deep.eq(["b"]);

        const elementsInB = await ab.canvases[0].replies.index.search(
            new SearchRequest({
                query: getImmediateRepliesQuery(ab.canvases[0]),
            })
        );

        const titlesFromB = await Promise.all(
            elementsInB.map((x) => x.createContext())
        );
        expect(titlesFromB.sort()).to.deep.eq(["c", "d"]);

        expect(root.replies.log.log.length).to.eq(5);

        const indexed = await root.replies.index.iterate().all();
        expect(indexed).to.have.length(5);

        /*  await delay(5e3) */

        const rootFromScopeFromAnotherNode = await session.peers[1].open(
            rootScope.clone()
        );

        await rootFromScopeFromAnotherNode.replies.index.waitFor(
            session.peers[0].identity.publicKey
        );

        const rootFromAnotherNode = await loadCanvasFromScopes(
            root.id,
            [rootFromScopeFromAnotherNode])

        if (!rootFromAnotherNode) {
            throw new Error("Root not found in another node");
        }


        // the root will contain all posts eventually because of the flattening
        await waitForResolved(async () => {
            expect(rootFromAnotherNode!.replies.log.log.length).to.eq(5);

            const allReplies = await rootFromAnotherNode!.replies.index
                .iterate({ query: [] }, { local: true })
                .all();
            expect(allReplies).to.have.length(5);
            for (const x of allReplies) {
                const title = await x.createContext();
                if (x.path.length > 0) {
                    expect(title.length > 0).to.be.true;
                }
            }
        });
    });

    describe("loadPath", () => {
        it("can load path with length", async () => {
            const rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            const [a, b, c] = await root.getCreateCanvasByPath(["a", "b", "c"]);
            const path = await c.loadPath({ length: 2, includeSelf: true });
            expect(path).to.have.length(3);
            expect(path.map((x) => x.idString)).to.deep.eq([
                a.idString,
                b.idString,
                c.idString,
            ]);
        });
    });
    describe("createRoot", () => {
        it("can create", async () => {
            let sections = ["About", "Help"];
            const { canvas: root } = await createRoot(session.peers[0], {
                persisted: true,
                sections,
            });
            expect(root).to.exist;

            const repliesCount = await root.replies.index.getSize();

            expect(repliesCount).to.eq(3);
            const replies = await root.replies.index
                .iterate({ query: getRepliesQuery(root) })
                .all();
            replies.sort((a, b) =>
                a.__indexed.context.localeCompare(b.__indexed.context)
            );
            const [first, second] = replies;

            const type = await root.getExperience();
            expect(type).to.not.exist;

            await checkContent(first, "About");
            await checkContent(second, "Help");

            expect(await first.getExperience()).to.eq(
                ChildVisualization.OUTLINE
            );
            expect(await second.getExperience()).to.eq(
                ChildVisualization.OUTLINE
            );

            // creating again should resolve in the same address
            const { canvas: root2 } = await createRoot(session.peers[1], {
                persisted: true,
                sections,
            });
            expect(root2.idString).to.eq(root.idString);

            await root2.replies.log.waitForReplicator(
                session.peers[0].identity.publicKey
            );
            const replies2 = await root2.replies.index
                .iterate({ query: getRepliesQuery(root) })
                .all();
            replies2.sort((a, b) =>
                a.__indexed.context.localeCompare(b.__indexed.context)
            );
            const [first2] = replies2;
            expect(first2.idString).to.eq(first.idString);
        });
    });

    describe("getStandaloneParent", () => {
        it("view context from root", async () => {
            const { canvas: root } = await createRoot(session.peers[0], {
                persisted: true,
            });
            expect(await root.getExperience()).to.be.undefined;
            const [feed] = await root.getCreateCanvasByPath(["Feed"]);

            const path = await feed.getCreateCanvasByPath(["a"]);
            const a = path[path.length - 1];
            await feed.unlink(a.id); // make child into standaly
            const rootFromA = await a.getStandaloneParent();
            expect(rootFromA![0].idString).to.eq(a.idString);

            const rootFromFeed = await feed.getStandaloneParent();
            expect(rootFromFeed![0].idString).to.eq(root.idString);

            const rootFromRoot = await root.getStandaloneParent();
            expect(rootFromRoot![0].idString).to.eq(root.idString);
        });

        it("root as feed", async () => {
            const rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));


            const [a] = await root.getCreateCanvasByPath(["a"]);

            expect(await a.hasParentLinks()).to.be.true;
            const rootFromC = await a.getStandaloneParent();
            expect(rootFromC?.map((x) => x.idString)).to.deep.eq([
                root.idString,
                a.idString,
            ]);
        });

        it("skips tab visualization", async () => {
            const rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));


            const [a, b, c] = await root.getCreateCanvasByPath(["a", "b", "c"]);

            const rootFromC = await c.getStandaloneParent();
            expect(rootFromC?.map((x) => x.idString)).to.deep.eq([
                root.idString,
                a.idString,
                b.idString,
                c.idString,
            ]);
        });

        it("root returns root", async () => {
            const rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            const rootFromRoot = await root.getStandaloneParent();
            expect(rootFromRoot?.map((x) => x.idString)).to.deep.eq([
                root.idString,
            ]);
        });
    });

    /*  describe("getFeedContext", () => {
         it("feed context from root", async () => {
             const root = await createRoot(session.peers[0], {
                 persisted: true,
             });
             const [feed] = await root.getCreateCanvasByPath(["Feed"]);
             const path = await feed.getCreateCanvasByPath(["a"]);
             const a = path[path.length - 1];
             const feedFromA = await a.getFeedContext();
             expect(feedFromA!.idString).to.eq(a.idString);
     
             const feedFromRoot = await root.getFeedContext();
             expect(feedFromRoot!.idString).to.eq(feed.idString);
         });
     
         it("narrative at root", async () => {
             const randomRootKey = (await Ed25519Keypair.create()).publicKey;
             const root = await session.peers[0].open(
                 new Canvas({
                     publicKey: randomRootKey,
                     seed: new Uint8Array(),
                capsules: 'root'
                 })
             );
     
             const [a, b, c] = await root.getCreateCanvasByPath(["a", "b", "c"]);
     
             await a.setMode("narrative");
             await b.setExperience(ChildVisualization.DOCUMENT);
     
             expect(await a.getType()).to.exist;
             expect(await b.getType()).to.exist;
             const feedFromA = await a.getFeedContext();
             expect(feedFromA?.idString).to.deep.eq(a.idString);
         });
     
         it("narrative at middle", async () => {
             const randomRootKey = (await Ed25519Keypair.create()).publicKey;
             const root = await session.peers[0].open(
                 new Canvas({
                     publicKey: randomRootKey,
                     seed: new Uint8Array(),
                capsules: 'root'
                 })
             );
     
             const [a, b, _c] = await root.getCreateCanvasByPath([
                 "a",
                 "b",
                 "c",
             ]);
     
             await a.setExperience(ChildVisualization.DOCUMENT);
             await b.setMode("narrative");
     
             expect(await a.getType()).to.exist;
             expect(await b.getType()).to.exist;
             const feedFromA = await a.getFeedContext();
             expect(feedFromA?.idString).to.deep.eq(b.idString);
         });
     }); */

    it("index once", async () => {
        const rootScope = await createOpenRootScope()
        const [_, root] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            selfScope: rootScope,
        }));

        let putIndexCalls = root.replies.index.putWithContext.bind(
            root.replies.index
        );

        let putCount = 0;
        root.replies.index.putWithContext = async (a, b, c) => {
            putCount++;
            return putIndexCalls(a, b, c);
        };
        await root.getCreateCanvasByPath(["a"]);
        expect(putCount).to.eq(1);
    });

    it("indexes replies", async () => {
        const rootScope = await createOpenRootScope()
        const [_, root1] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            selfScope: rootScope,
        }));

        const [a, b] = await root1.getCreateCanvasByPath(["a", "b"]); // no layout, means the last post will be of a n

        const fetchedA = await root1.replies.index.get(a.id);
        expect(Number(fetchedA!.__indexed.replies)).to.eq(1); // a has one reply (b)
        const fetchedB = await root1.replies.index.get(b.id);
        expect(Number(fetchedB.__indexed.replies)).to.eq(0); // b has no replies
    });

    it("indexes replies ignores navigational posts", async () => {
        const rootScope = await createOpenRootScope()
        const [_, root1] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            selfScope: rootScope,
        }));


        let [a, b, c] = await root1.getCreateCanvasByPath(["a", "b", "c"]);
        await a.setChildPosition(b.id, 0)

        // indexer is async so we need to try and wait
        await waitForResolved(async () => {
            let [aFetched, bFetched, cFetched] = await Promise.all([a, b, c].map(x => root1.replies.index.get(x.id)));
            expect(Number(aFetched.__indexed.replies)).to.eq(1);
            expect(Number(bFetched.__indexed.replies)).to.eq(1);
            expect(Number(cFetched.__indexed.replies)).to.eq(0);
        })


        let [aMod, bMod, cMod] = await root1.getCreateCanvasByPath([
            "a",
            "b",
            "c",
        ]);

        await aMod.unlink(bMod.id);



        // indexer is async so we need to try and wait
        await waitForResolved(async () => {
            let [aModFetched, bModFetched, cModFetched] = await Promise.all([aMod, bMod, cMod].map(x => root1.replies.index.get(x.id)));
            expect(Number(aModFetched.__indexed.replies)).to.eq(2);
            expect(Number(bModFetched.__indexed.replies)).to.eq(1);
            expect(Number(cModFetched.__indexed.replies)).to.eq(0);
        })
    });

    /*
    //  TODO for keep: 'self' property is used and a remote not is modifying the same document, updates will not be propagate
    // this will lead to issues when working with indexed data and fetching stuff "local first"
     
    it("will not re-index parents if not replicating", async () => {
         const randomRootKey = (await Ed25519Keypair.create()).publicKey;
         const root1 = await session.peers[0].open(
             new Canvas({
                 publicKey: randomRootKey,
                 seed: new Uint8Array(),
                capsules: 'root'
             })
         );
         const [a1] = await root1.getCreateCanvasByPath(["a"]);
     
         const root2 = await session.peers[1].open(root1.clone(), {
             args: {
                 replicate: false,
             },
         });
     
         await root2.replies.log.waitForReplicators({ waitForNewPeers: true });
     
         let putIndexCalls = root2.replies.index.putWithContext.bind(
             root2.replies.index
         );
     
         let putCount = 0;
         await root2.load();
         root2.replies.index.putWithContext = async (a, b, c) => {
             putCount++;
             return putIndexCalls(a, b, c);
         };
     
         const [a2, b2] = await root2.getCreateCanvasByPath(["a", "b"]);
         await waitForResolved(async () => expect(Number(await a1.countReplies({ onlyImmediate: true }))).to.eq(1))
     
         expect(putCount).to.eq(1);
     
         const checkReplies = async (root: Canvas) => {
             const a = await root.getCreateCanvasByPath(["a"])
             expect(a).to.have.length(1);
             const asIndexed = a[0] as WithIndexedContext<Canvas, IndexableCanvas>;
     
             expect(asIndexed.__indexed).to.exist; // root + a
             expect(Number(await a1.countReplies({ onlyImmediate: true }))).to.eq(1);
             expect(Number(asIndexed.__indexed.replies)).to.eq(1); // a has one reply (b)
         }
     
         await checkReplies(root1);
         await checkReplies(root2);
     
     
     
     }); */
    it("same path", async () => {
        const rootScope = await createOpenRootScope()
        const [_, root1] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            selfScope: rootScope,
        }));

        const indexSize = await root1.replies.index.getSize();
        expect(indexSize).to.eq(1);

        const [a1] = await root1.getCreateCanvasByPath(["a"]);

        const indexSize1 = await root1.replies.index.getSize();
        expect(indexSize1).to.eq(2);

        const [a2, b2] = await root1.getCreateCanvasByPath(["a", "b"]);

        const indexSize2 = await root1.replies.index.getSize();
        expect(indexSize2).to.eq(3);
    });

    it("can reload", async () => {
        let rootScope = await createOpenRootScope()
        const [_, root] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            selfScope: rootScope,
        }));

        let [a] = await root.getCreateCanvasByPath(["a"]);
        await root.getCreateCanvasByPath(["a", "b"]);
        await root.getCreateCanvasByPath(["a", "c"]);

        const allReplies = await a.replies.index
            .iterate({ query: getImmediateRepliesQuery(a) })
            .all();
        expect(allReplies).to.have.length(2);

        const elements = await a.elements.index
            .iterate({ query: getOwnedElementsQuery(a) })
            .all();
        expect(elements).to.have.length(1);

        await rootScope.close();
        rootScope = await session.peers[0].open(rootScope.clone());

        const allRepliesAfterReload = await rootScope.replies.index
            .iterate({ query: getImmediateRepliesQuery(root) })
            .all();

        expect(allRepliesAfterReload).to.have.length(1);

        const elementsAfterReload = await rootScope.elements.index
            .iterate({ query: getOwnedElementsQuery(a) })
            .all();
        expect(elementsAfterReload).to.have.length(1);
    });

    it("can reload subpath only ", async () => {
        await session.stop();

        let directory = "./tmp/can reload subpath only/" + +new Date();
        session = await TestSession.connected(1, { directory });
        let peer = session.peers[0];

        const rootScope = await createOpenRootScope()
        const [_, root] = await rootScope.getOrCreateReply(new Canvas({
            publicKey: session.peers[0].identity.publicKey,
            selfScope: rootScope,
        }));


        const [a, b] = await root.getCreateCanvasByPath(["a", "b"]);
        const experience = await peer.services.blocks.get(rootScope.address);
        expect(experience).to.exist;

        await peer.stop();

        // session = await TestSession.connected(1, { directory });
        // peer = session.peers[0] as any;
        peer = await Peerbit.create({ directory });

        const experienceAgain = await peer.services.blocks.get(rootScope.address);
        expect(experienceAgain).to.exist;
    });

    describe("replies", () => {
        it("index 1 reply", async () => {
            let rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            const [a, b] = await root.getCreateCanvasByPath(["a", "b"]);

            expect(a).to.exist;
            expect(b).to.exist;

            // index updates are not immediate, so we do checks until it's updated
            await waitForResolved(async () => {
                const countedAllRepliesFromRoot = await root.countReplies();
                expect(countedAllRepliesFromRoot).to.eq(2n); // a immediate child of root, b immediate child of a

                const countedImmediateRepliesFromRoot = await root.countReplies(
                    { onlyImmediate: true }
                );
                expect(countedImmediateRepliesFromRoot).to.eq(1n); // a immediate child of root

                const replies = await root.replies.index
                    .iterate(
                        { query: getImmediateRepliesQuery(root) },
                        { resolve: false }
                    )
                    .all();
                expect(replies).to.have.length(1);
                expect(replies[0].context).to.eq("a");
                expect(replies[0].replies).to.eq(1n); // one reply (b)
            });
        });

        it("getRepliesQuery", async () => {
            let rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            await root.getCreateCanvasByPath(["a", "b", "c"]);
            await root.getCreateCanvasByPath(["a", "b", "d"]);
            const a = (await root.getCreateCanvasByPath(["a"]))[0];
            expect(await a.createContext()).to.eq("a");

            const all = await a.replies.index
                .iterate({
                    query: getRepliesQuery(a),
                })
                .all();
            // should return all children
            // b, c, d
            expect(all).to.have.length(3);
            const allTitles = await Promise.all(
                all.map((x) => x.createContext())
            );
            expect(allTitles.sort()).to.deep.eq(["b", "c", "d"]);
        });

        it("getImmediateRepliesQuery", async () => {
            let rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));
            await root.getCreateCanvasByPath(["a", "b", "c"]);
            await root.getCreateCanvasByPath(["a", "b", "d"]);
            const [_a, b] = await root.getCreateCanvasByPath(["a", "b"]);
            expect(await b.createContext()).to.eq("b");

            const all = await b.replies.index
                .iterate({
                    query: getImmediateRepliesQuery(b),
                })
                .all();

            const allTitles = await Promise.all(
                all.map((x) => x.createContext())
            );
            expect(allTitles.sort()).to.deep.eq(["c", "d"]);
        });

        it("can sort by replies", async () => {
            let rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));
            const p1 = await root.getCreateCanvasByPath(["b", "b"]); // no layout, means the last post will be of a narrative type
            const p2 = await root.getCreateCanvasByPath(["a", "b"]); // no layout, means the last post will be of a narrative type
            const p3 = await root.getCreateCanvasByPath(["c"]); // no layout, means the last post will be of a narrative type
            const p4 = await root.getCreateCanvasByPath(["a", "c"]); // no layout, means the last post will be of a narrative type

            await root.unlink(p1[0].id); // make b into narrative post
            await root.unlink(p2[0].id); // make a into narrative post
            await root.unlink(p3[0].id); // make c into narrative post
            await root.unlink(p4[0].id); // make a into narrative post

            const sortedByReplies = await root.replies.index.search({
                query: getImmediateRepliesQuery(root),
                sort: new Sort({
                    key: "replies",
                    direction: SortDirection.DESC,
                }),
            });
            expect(
                await Promise.all(sortedByReplies.map((x) => x.createContext()))
            ).to.deep.eq(["a", "b", "c"]);
        });

        it("will use remote for sorting during warmup", async () => {
            let rootScope = await createOpenRootScope()
            const [_, rootA] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            let childrenCount = {
                a: 1,
                b: 2,
                c: 3,
            };

            for (const [key, count] of Object.entries(childrenCount)) {
                for (let i = 0; i < count; i++) {
                    // console.log("key: " + key + "key", "i", i)
                    await rootA.getCreateCanvasByPath([key, i.toString()]); // no layout, means the last post will be of a narrative type
                }
            }

            // a has 1 reply
            // b has 2 replies
            // c has 3 replies

            // so sorting by replies will be c, b, a
            const results = async (scope: Scope, root: Canvas) => {
                const sorted = await root.replies.index
                    .iterate({
                        query: getImmediateRepliesQuery(root),
                        sort: new Sort({
                            key: "replies",
                            direction: SortDirection.DESC,
                        }),
                    })
                    .all();

                /*  for (const [i, r] of sorted.entries()) {
                     if (r.closed) {
                         sorted[i] = await root.node.open(r, {
                             existing: "reuse",
                         });
                     }
                 } */
                const titles = await Promise.all(
                    sorted.map((x) => x.createContext())
                );
                expect(titles).to.deep.eq(["c", "b", "a"]);
            };
            await results(rootScope, rootA);

            const rootScopeB = await session.peers[1].open(rootScope.clone(), {
                args: {
                    replicate: false,
                },
            });
            await rootScopeB.replies.log.waitForReplicators();
            await results(rootScopeB, rootA);
        });

        it("will use remote for sorting during warmup when not replicating", async () => {
            let rootScope = await createOpenRootScope()
            const [_, rootA] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            let childrenCount = {
                a: 1,
                b: 2,
                c: 3,
            };

            for (const [key, count] of Object.entries(childrenCount)) {
                for (let i = 0; i < count; i++) {
                    // console.log("key: " + key + "key", "i", i)
                    await rootA.getCreateCanvasByPath([key, i.toString()]); // no layout, means the last post will be of a narrative type
                }
            }

            // a has 1 reply
            // b has 2 replies
            // c has 3 replies

            // so sorting by replies will be c, b, a
            const results = async (scope: Scope, root: Canvas) => {
                const sorted = await scope.replies.index
                    .iterate({
                        query: getImmediateRepliesQuery(root),
                        sort: new Sort({
                            key: "replies",
                            direction: SortDirection.DESC,
                        }),
                    })
                    .all();

                /* for (const [i, r] of sorted.entries()) {
                    if (r.closed) {
                        sorted[i] = await root.node.open(r, {
                            existing: "reuse",
                            args: {
                                replicate: false,
                            },
                        });
                    }
                } */

                await delay(3e3);
                const titles = await Promise.all(
                    sorted.map((x) => x.createContext())
                );
                expect(titles).to.deep.eq(["c", "b", "a"]);
            };
            await results(rootScope, rootA);

            const rootScopeB = await session.peers[1].open(rootScope.clone(), {
                args: {
                    replicate: false,
                },
            });

            await rootScopeB.replies.log.waitForReplicators({ roleAge: 5e3 });
            await results(rootScope, rootA);
        });

        it("can sort by replies after restart", async () => {
            await session.stop();

            session = await TestSession.connected(1, {
                directory: "./tmp/can-sort-after-restart/" + +new Date(),
            });

            let rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            await root.getCreateCanvasByPath(["b", "b"]);
            await root.getCreateCanvasByPath(["a", "b"]);
            await root.getCreateCanvasByPath(["c"]);
            await root.getCreateCanvasByPath(["a", "c"]);

            const checkSort = async () => {
                const sortedByReplies = await rootScope.replies.index.search({
                    query: getImmediateRepliesQuery(root),
                    sort: new Sort({
                        key: "replies",
                        direction: SortDirection.DESC,
                    }),
                });
                expect(
                    await Promise.all(
                        sortedByReplies.map((x) => rootScope.createContext(x))
                    )
                ).to.deep.eq(["a", "b", "c"]);
            };

            await checkSort();
            await rootScope.close();
            rootScope = await session.peers[0].open(rootScope.clone(), {
                existing: "reject",
            });
            await checkSort();
        });

        it("can sort by replies as non replicator", async () => {

            let rootScope = await createOpenRootScope({ replicate: false })
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));




            let replicator = await session.peers[1].open(rootScope.clone());

            const p1 = await root.getCreateCanvasByPath(["b", "b"]); // no layout, means the last post will be of a narrative type
            const p2 = await root.getCreateCanvasByPath(["a", "b"]); // no layout, means the last post will be of a narrative type
            const p3 = await root.getCreateCanvasByPath(["c"]); // no layout, means the last post will be of a narrative type
            const p4 = await root.getCreateCanvasByPath(["a", "c"]); // no layout, means the last post will be of a narrative type

            await root.unlink(p1[0].id); // make b into narrative post
            await root.unlink(p2[0].id); // make a into narrative post
            await root.unlink(p3[0].id); // make c into narrative post
            await root.unlink(p4[0].id); // make a into narrative post

            await waitForResolved(() =>
                expect(replicator.replies.log.log.length).to.eq(7)
            );

            const checkSort = async () => {
                const sortedByReplies = await rootScope.replies.index.search({
                    query: getImmediateRepliesQuery(root),
                    sort: new Sort({
                        key: "replies",
                        direction: SortDirection.DESC,
                    }),
                });
                expect(
                    await Promise.all(
                        sortedByReplies.map((x) => rootScope.createContext(x))
                    )
                ).to.deep.eq(["a", "b", "c"]);
            };

            await checkSort();
            await rootScope.close();
            rootScope = await session.peers[0].open(rootScope.clone(), {
                existing: "reject",
                args: {
                    replicate: false,
                },
            });
            await checkSort();
        });

        it("can index partially", async () => {

            let viewer = await createOpenRootScope({
                replicate: false,
                replicas: {
                    min: 1,
                },
            })


            let replicator = await session.peers[1].open(viewer.clone(), {
                args: {
                    replicas: {
                        min: 1,
                    },
                },
            });
            const [_, rootReplicator] = await replicator.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: replicator
            }));



            await rootReplicator.getCreateCanvasByPath(["a", "b"]); // no layout, means the last post will be of a narrative type

            const all = await viewer.replies.index.search({
                sort: new Sort({
                    key: "replies",
                    direction: SortDirection.DESC,
                }),
            });
            const first = all[0];
            expect(await viewer.createContext(first)).to.eq("a");

            const entry = await replicator.replies.log.log.get(
                first.__context.head
            );
            await viewer.replies.log.replicate(entry);

            await waitForResolved(() =>
                expect(viewer.replies.log.log.length).to.eq(1)
            );
            expect(await viewer.replies.log.isReplicating()).to.be.true;
        });

        it("two way replication", async () => {

            let first = await createOpenRootScope({ replicate: false })
            const [_, root] = await first.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: first
            }));

            await root.getCreateCanvasByPath(["a", "b"]);

            let second = await session.peers[1].open(first.clone(), {
                args: {
                    replicate: true,
                },
            });

            await waitForResolved(() =>
                expect(second.replies.log.log.length).to.eq(3)
            );

            await first.close();

            first = await session.peers[0].open(second.clone(), {
                existing: "reuse",
                args: {
                    replicate: true,
                },
            });
            await waitForResolved(() =>
                expect(first.replies.log.log.length).to.eq(3)
            );
        });

        describe("removeAllReplies", () => {
            it("can remove all", async () => {
                let rootScope = await createOpenRootScope({ replicate: false })
                const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: rootScope,
                }));

                const [a, _b, _c] = await root.getCreateCanvasByPath([
                    "a",
                    "b",
                ]);
                await a.removeAllReplies();

                await checkCountAllReplies(root, 1);
                await checkCountImmediateReplies(root, 1);
            });

            it("can remove and recover in another scope", async () => {

                await session.stop();

                let directory = "./tmp/can reload subpath only/" + +new Date();
                session = await TestSession.connected(1, { directory });

                const rootScope = await createOpenRootScope()
                const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: rootScope,
                }));


                const temporaryScope = await createOpenRootScope();


                // draft a message
                const [created, reply] = await root.createReply(new Canvas({ parent: root, publicKey: session.peers[0].identity.publicKey, selfScope: temporaryScope }));
                expect(reply.nearestScope.address).to.eq(temporaryScope.address);
                await reply.addTextElement("hello", /* { scope: temporaryScope } */)
                console.log("TEMP SCOPE", temporaryScope.address);

                expect(await rootScope.replies.index.get(reply.id)).to.not.exist;
                expect(await temporaryScope.replies.index.get(reply.id)).to.exist;

                const clonedReply = reply.clone();
                clonedReply.selfScope = rootScope;

                const [createdAgain, reply2] = await root.createReply(clonedReply)


                expect(created).to.be.true;
                expect(createdAgain).to.be.true;
                expect(reply2.idString).to.eq(reply.idString);
                expect(await reply.getText()).to.eq("hello");

                const heads = await rootScope.replies.index.iterate().all()
                for (const head of heads) {
                    const existing = await rootScope.replies.log.log.get(head.__context.head);
                    expect(existing).to.exist;
                }
                const tempHeads = await temporaryScope.replies.index.iterate().all()
                for (const head of tempHeads) {
                    const existing = await temporaryScope.replies.log.log.get(head.__context.head);
                    expect(existing).to.exist;
                }


                await temporaryScope.remove(reply); // remove from temporaryScope, but still expect that reply2 exist in full

                for (const head of heads) {
                    const existing = await rootScope.replies.log.log.get(head.__context.head);
                    expect(existing).to.exist;
                }

                for (const head of heads) {
                    const existing = await temporaryScope.replies.log.log.get(head.__context.head);
                    expect(existing).to.not.exist;
                }




                expect(await reply.getText({ scope: temporaryScope })).to.eq("")
                expect(await reply2.getText({ scope: rootScope })).to.eq("hello");

                // restart and see if persists
                const preId = session.peers[0].identity.publicKey.hashcode();

                await session.stop();
                session = await TestSession.connected(1, { directory });
                let anotherRootAgain = await session.peers[0].open(rootScope.clone(), {
                    existing: "reuse",
                    args: {
                        replicate: true,
                    },
                });


                let repliesFromRoot = await anotherRootAgain.replies.index.iterate({}, { remote: { eager: true, joining: { waitFor: 1e3, } } }).all();
                expect(repliesFromRoot).to.have.length(2); // root + reply
                const [replyFromRoot] = repliesFromRoot;

                const headsAgain = await anotherRootAgain.replies.index.iterate().all()
                for (const head of headsAgain) {
                    const existing = anotherRootAgain.replies.log.log.get(head.__context.head);
                    expect(existing).to.exist;
                }

                await waitForResolved(async () => expect(await anotherRootAgain.getText(replyFromRoot)).to.eq("hello"));
            })
        });

        describe("createReply", () => {
            it("updates parent", async () => {
                const rootScope = await createOpenRootScope()
                const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: rootScope,
                }));

                let anotherRootScope = await session.peers[0].open(await createOpenRootScope(), {
                    args: {
                        replicate: true,
                    }
                }
                );

                const [__, anotherRoot] = await anotherRootScope.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: anotherRootScope
                }));

                const [a, _b] = await anotherRoot.getCreateCanvasByPath([
                    "a",
                    "b",
                ]);
                const [created, reply] = await root.createReply(a);

                // new parent
                expect(equals(reply.path[0].path[0], root.id)).to.be.true;
                expect(reply.idString).to.not.eq(a.idString);

                await anotherRoot.removeAllReplies();
                expect(created).to.be.true;
                await checkContent(reply, "a");
                const firstChild = await getCheckOneReply(reply);
                await checkContent(firstChild, "b");
            });

            it("another origin same parent createReply from", async () => {
                const rootScope = await createOpenRootScope()
                const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: rootScope,
                }));


                const anotherRootScope = await createOpenRootScope()


                //  setParent same as set reply?

                const [___, replyCustom] = await anotherRootScope.getOrCreateReply(new Canvas({
                    parent: root,
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: anotherRootScope,
                }));


                expect(await rootScope.replies.index.get(replyCustom.id)).to.not.exist;
                expect(await anotherRootScope.replies.index.get(replyCustom.id)).to.exist;

                /*   await replyCustom.load(rootScope); */

                await replyCustom.links.put(
                    new LinkPlacement({
                        parent: root.id,
                        child: replyCustom.id,
                        kind: new ViewKind({ orderKey: "0" }),
                    })
                );
                await replyCustom.addTextElement("a");
                await replyCustom.getCreateCanvasByPath(["b"], {
                    layout: new Layout({ x: 1 }),
                });

                await delay(1000); // wait for indexer to update
                expect(await anotherRootScope.replies.index.get(replyCustom.id)).to.exist;
                expect(await rootScope.replies.index.get(replyCustom.id)).to.not.exist;

                const [created, reply] = await root.createReply(replyCustom); // SET CUSTOM ORIGIN? OR anotherOrigin.createReply(parent ??? )

                // same parent
                expect(equals(reply.path[0].path[0], root.id)).to.be.true;
                expect(reply.idString).to.eq(replyCustom.idString);

                await anotherRootScope.removeAllReplies();

                expect(created).to.be.true;
                await checkContent(reply, "a");
                const firstChild = await getCheckOneReply(reply);
                await checkContent(firstChild, "b");
            });

            it("will merge children", async () => {

                const rootScope = await createOpenRootScope()
                const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: rootScope,
                }));


                const rootScope2 = await createOpenRootScope()
                const [__, anotherRoot] = await rootScope.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: rootScope,
                }));


                const [a] = await anotherRoot.getCreateCanvasByPath(["a"]);
                const [created, reply] = await root.createReply(a);
                await checkContent(a, "a");

                /*   expect(created).to.be.true;
                   await checkContent(reply, "a"); */

                const [aAgain, b] = await anotherRoot.getCreateCanvasByPath([
                    "a",
                    "b",
                ]);
                const [createdAgain, replyAgain] = await root.createReply(a);
                expect(createdAgain).to.be.true;
                await checkContent(replyAgain, "a");
                const firstChild = await getCheckOneReply(replyAgain);
                await checkContent(firstChild, "b");
            });

            it("deduplicates", async () => {
                const rootScope = await createOpenRootScope()
                const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: rootScope,
                }));


                const rootScope2 = await createOpenRootScope()
                const [__, anotherRoot] = await rootScope.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: rootScope,
                }));

                const canvas = new Canvas({ parent: anotherRoot, publicKey: session.peers[0].identity.publicKey });
                const [created, reply] = await root.createReply(canvas);

                expect(created).to.be.true;

                // insert again and check not created and replies has not grown

                const [createdAgain, replyAgain] = await root.createReply(reply);
                expect(createdAgain).to.be.false;
                expect(replyAgain.idString).to.eq(reply.idString);

                const repliesCount = await root.countReplies();
                expect(repliesCount).to.eq(1n);

            })

            /*    it("can use different scope", async () => {
     
                   let scope1 = await createOpenRootScope()
                   let scope2 = await createOpenRootScope();
     
                   const [_, root] = await scope1.getOrCreateReply(new Canvas({
                       publicKey: session.peers[0].identity.publicKey,
                       selfScope: scope1,
                   }));
     
                   const canvas = new Canvas({ parent: root, publicKey: session.peers[0].identity.publicKey, selfScope: scope2, });
                   const [created, reply] = await root.createReply(canvas, { kind: new ViewKind({ orderKey: "0" }), type: ChildVisualization.OUTLINE });
                   await reply.addTextElement("test");
     
                   expect(created).to.be.true;
                   expect(reply.selfScope?.idString).to.eq(scope1.idString); // should be in scope1 even if we used the scope2 to create the reply
     
                   // check that scope1 is empty 
                   expect(await scope1.replies.index.getSize()).to.eq(0);
                   expect(await scope1.elements.index.getSize()).to.eq(0);
                   expect(await scope1.links.index.getSize()).to.eq(0);
     
                   // check that scope2 is not empty
                   expect(await scope2.replies.index.getSize()).to.eq(1);
                   expect(await scope2.elements.index.getSize()).to.eq(1);
                   expect(await scope2.links.index.getSize()).to.eq(1);
     
     
                   // insert again and check not created and replies has not grown
                   const [createdAgain, replyAgain] = await root.createReply(canvas, { layout: new Layout({ x: 1 }), type: ChildVisualization.FEED });
     
                   expect(createdAgain).to.be.false;
                   expect(replyAgain.idString).to.eq(reply.idString);
     
     
                   // insert it in the first scope 
                   const cloneInAnotherScope = canvas.clone();
                   await cloneInAnotherScope.updateScope([scope1]);
     
                   const [createdAgain2, replyAgain2] = await root.createReply(cloneInAnotherScope);
                   expect(createdAgain2).to.be.true;
                   expect(replyAgain2.idString).to.eq(reply.idString); // same address, but just created in another scope
     
                   // check that scope1 is not empty 
                   expect(await scope1.replies.index.getSize()).to.eq(1);
                   expect(await scope1.elements.index.getSize()).to.eq(1);
                   expect(await scope1.links.index.getSize()).to.eq(1);
     
                   // check that scope1 is not empty 
                   expect(await scope2.replies.index.getSize()).to.eq(1);
                   expect(await scope2.elements.index.getSize()).to.eq(1);
                   expect(await scope2.links.index.getSize()).to.eq(1);
     
     
               })
    */
            it("can re-open with different scope", async () => {

                await session.stop();

                let directory = "./tmp/can re-open with different scope/" + +new Date();
                session = await TestSession.connected(1, { directory });


                let scope1 = await createOpenRootScope()
                const [_, root] = await scope1.getOrCreateReply(new Canvas({
                    publicKey: session.peers[0].identity.publicKey,
                    selfScope: scope1
                }));

                let scope2 = await createOpenRootScope();

                const [created, reply] = await root.createReply(new Canvas({ selfScope: scope2, parent: root, publicKey: session.peers[0].identity.publicKey }));
                await reply.addTextElement("hello")

                await session.stop();
                session = await TestSession.connected(1, { directory });
                scope1 = await session.peers[0].open(scope1, {
                    existing: "reuse",
                    args: {
                        replicate: true,
                    },
                });

                scope2 = await createOpenRootScope({ seed: scope2.clone() });

                let t0 = +new Date();
                let repliesFromRoot = await scope2.replies.index.iterate().all();
                let t1 = +new Date();
                expect(t1 - t0).to.be.lessThan(1e3)
                expect(repliesFromRoot).to.have.length(1);
                const [replyFromRoot] = repliesFromRoot;

                /*              let replyFromRootOpen = await session.peers[0].open(replyFromRoot, {
                                 existing: "reuse",
                                 args: {
                                     replicate: true,
                                 },
                             }) */

                expect(await replyFromRoot.getText({ scope: scope2 })).to.eq("hello");
                /*  ; */





            })


        });
    });

    describe("elements", async () => {
        it("can query by ownership", async () => {
            const rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            const [a] = await root.getCreateCanvasByPath(["a"]);
            await root.getCreateCanvasByPath(["a", "b1"]);
            await root.getCreateCanvasByPath(["a", "b2"]);

            expect(await a.createContext()).to.eq("a");

            const ownedElements = await a.elements.index
                .iterate({
                    query: getOwnedElementsQuery(a),
                })
                .all();

            expect(ownedElements).to.have.length(1);
        });

        it("can query by type", async () => {
            const rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            const [a] = await root.getCreateCanvasByPath(["a"]);
            await root.getCreateCanvasByPath(["a", "b1"]);

            const [__, subcanvasWithImage] = await a.createReply(new Canvas({
                parent: a,
                publicKey: session.peers[0].identity.publicKey,
            }))

            /*       await subcanvasWithImage.load(); */
            await subcanvasWithImage.elements.put(
                new Element({
                    content: new StaticContent({
                        content: new StaticImage({
                            data: new Uint8Array([1, 2, 3, 4]),
                            height: 100,
                            width: 100,
                            mimeType: "image/png",
                        }),
                        contentId: sha256Sync(new Uint8Array([1, 2, 3, 4])),
                        quality: LOWEST_QUALITY,
                    }),
                    canvasId: subcanvasWithImage.id,
                    location: Layout.zero(),
                    publicKey: session.peers[0].identity.publicKey,
                })
            );

            /*  await a.load(); */
            await a.createReply(subcanvasWithImage);

            const ownedElements = await a.elements.index
                .iterate({
                    query: getOwnedElementsQuery(a),
                })
                .all();

            expect(ownedElements).to.have.length(1); // self

            const ownedTextElements = await a.elements.index
                .iterate({
                    query: [
                        ...getOwnedElementsQuery(a),
                        getTextElementsQuery(),
                    ],
                })
                .all();

            expect(ownedTextElements).to.have.length(1); // self + text reply

            const ownedImageElements = await subcanvasWithImage.elements.index
                .iterate({
                    query: [
                        ...getOwnedElementsQuery(subcanvasWithImage),
                        getImagesQuery(),
                    ],
                })
                .all();

            expect(ownedImageElements).to.have.length(1); // image reply
        });
    });

    describe("path", () => {
        it("setParent", async () => {
            const rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            const [_a, _b, c] = await root.getCreateCanvasByPath([
                "a",
                "b",
                "c",
            ]);
            const [a] = await root.getCreateCanvasByPath(["a"]);
            const [__a, b] = await root.getCreateCanvasByPath(["a", "b"]);
            expect(a.path).to.have.length(1);
            expect(a.path[0].path).to.have.length(3);
            expect(equals(c.path[0][0], root.id)).to.be.true;
            expect(equals(c.path[0][1], a.id)).to.be.true;
            expect(equals(c.path[0][2], b.id)).to.be.true;

            let cElements = await c.elements.index
                .iterate({ query: getOwnedElementsQuery(c) })
                .all();
            expect(cElements).to.have.length(1);
            expect(cElements[0].canvasId).to.deep.eq(c.id);

            await c.setParent(a);
            const checkCanvas = async (c: Canvas) => {
                expect(a.path).to.have.length(1);
                expect(a.path[0].path).to.have.length(2);
                expect(equals(c.path[0][0], root.id)).to.be.true;
                expect(equals(c.path[0][1], a.id)).to.be.true;

                cElements = await c.elements.index
                    .iterate({ query: getOwnedElementsQuery(c) })
                    .all();
                expect(cElements).to.have.length(1);
                expect(cElements[0].canvasId).to.deep.eq(c.id);
            };
            await checkCanvas(c);

            // also check c from another peer that is querying the canvas
            const rootScope2 = await session.peers[1].open(rootScope, {
                existing: "reuse",
                args: {
                    replicate: false,
                },
            });

            await rootScope2.replies.log.waitForReplicators({
                waitForNewPeers: true,
            });
            const [__, root2] = await rootScope2.getOrCreateReply(root);
            const [_a2, c2] = await root2.getCreateCanvasByPath(["a", "c"]);
            await checkCanvas(c2);
        });

        // TODO implement sub elements move
    });

    describe("visualization", () => {
        it("can set visualization", () => { });
    });
    /*  it("determinstic with seed", async () => {
         let seed = new Uint8Array([0, 1, 2]);
         const rootA = await session.peers[0].open(
             new Canvas({
                 seed,
                 rootTrust: session.peers[0].identity.publicKey,
             })
         );
         const pathA = await rootA.getCreateCanvasByPath(["a", "b", "c"]);
     
         await session.peers[0].stop();
         await session.peers[0].start();
     
         const rootB = await session.peers[0].open(
             new Canvas({
                 seed,
                 rootTrust: session.peers[0].identity.publicKey,
             })
         );
     
         expect(rootA.address).to.eq(rootB.address);
     
         const pathB = await rootB.getCreateCanvasByPath(["a", "b", "c"]);
         for (const room of pathB) {
             await session.peers[0].open(room);
         }
     
         expect(typeof pathA[pathA.length - 1].address).to.eq("string");
         expect(pathA[pathA.length - 1].address).to.eq(
             pathB[pathB.length - 1].address
         );
     }); */
    describe("diffCanvases", async () => {

        it("same", async () => {
            const rootScope = await createOpenRootScope()
            const [_, root] = await rootScope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: rootScope,
            }));

            const [a] = await root.getCreateCanvasByPath(["a"]);
            const scope = await createOpenRootScope()

            const aAgain = deserialize(serialize(a), Canvas);
            const diff = await diffCanvases({ canvas: a, scope }, { canvas: aAgain, scope });
            expect(diff).be.false;
        })

        it("diff", async () => {
            const scope = await createOpenRootScope()
            const [_, root] = await scope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                selfScope: scope
            }));

            const [a] = await root.getCreateCanvasByPath(["a"]);
            const [_a, b] = await root.getCreateCanvasByPath(["a", "b"]);
            const diff = await diffCanvases({ canvas: a, scope }, { canvas: b, scope });
            expect(diff).be.true;
        })
        it("diff in different scopes", async () => {

            const scope = await createOpenRootScope()
            const anotherScope = await createOpenRootScope()

            const [_, root] = await scope.getOrCreateReply(new Canvas({
                publicKey: session.peers[0].identity.publicKey,
                seed: new Uint8Array(),
                selfScope: scope,
            }))

            const diff = await diffCanvases({ canvas: root, scope }, { canvas: root, scope });
            expect(diff).be.false;

            await root.addTextElement("hello"/* , { scope: anotherScope } */)

            const diffAgain = await diffCanvases({ canvas: root, scope: scope }, { canvas: root, scope: anotherScope });
            expect(diffAgain).be.true;
        })
    })
});

