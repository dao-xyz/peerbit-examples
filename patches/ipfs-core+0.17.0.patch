diff --git a/node_modules/ipfs-core/src/components/libp2p.js b/node_modules/ipfs-core/src/components/libp2p.js
index 1c1b57c..7457a5e 100644
--- a/node_modules/ipfs-core/src/components/libp2p.js
+++ b/node_modules/ipfs-core/src/components/libp2p.js
@@ -48,30 +48,30 @@ const mergeOptions = mergeOpts.bind({ ignoreUndefined: true, concatArrays: true
  * @param {KeychainConfig|undefined} config.keychainConfig
  * @param {Partial<IPFSConfig>|undefined} config.config
  */
-export function createLibp2p ({
-  options = {},
-  peerId,
-  multiaddrs = [],
-  repo,
-  keychainConfig = {},
-  config = {}
-}) {
-  const { datastore } = repo
-
-  const libp2pOptions = getLibp2pOptions({
-    options,
-    config,
-    datastore,
-    keychainConfig,
+export function createLibp2p({
+    options = {},
     peerId,
-    multiaddrs
-  })
+    multiaddrs = [],
+    repo,
+    keychainConfig = {},
+    config = {}
+}) {
+    const { datastore } = repo
+
+    const libp2pOptions = getLibp2pOptions({
+        options,
+        config,
+        datastore,
+        keychainConfig,
+        peerId,
+        multiaddrs
+    })
 
-  if (typeof options.libp2p === 'function') {
-    return options.libp2p({ libp2pOptions, options, config, datastore, peerId })
-  }
+    if (typeof options.libp2p === 'function') {
+        return options.libp2p({ libp2pOptions, options, config, datastore, peerId })
+    }
 
-  return createNode(libp2pOptions)
+    return createNode(libp2pOptions)
 }
 
 /**
@@ -84,161 +84,161 @@ export function createLibp2p ({
  * @param {Multiaddr[]} input.multiaddrs
  * @returns {Libp2pOptions}
  */
-function getLibp2pOptions ({ options, config, datastore, keychainConfig, peerId, multiaddrs }) {
-  const getPubsubRouter = () => {
-    const router = get(config, 'Pubsub.Router') || 'gossipsub'
+function getLibp2pOptions({ options, config, datastore, keychainConfig, peerId, multiaddrs }) {
+    const getPubsubRouter = () => {
+        const router = get(config, 'Pubsub.Router') || 'gossipsub'
+
+        const availableRouters = routers()
 
-    const availableRouters = routers()
+        if (!availableRouters[router]) {
+            throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED')
+        }
 
-    if (!availableRouters[router]) {
-      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED')
+        return availableRouters[router]
     }
 
-    return availableRouters[router]
-  }
-
-  /** @type {Libp2pOptions} */
-  const libp2pDefaults = {
-    datastore,
-    peerId: peerId
-  }
-
-  /** @type {Libp2pOptions} */
-  const libp2pOptions = {
-    addresses: {
-      listen: multiaddrs.map(ma => ma.toString()),
-      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),
-      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))
-    },
-    connectionManager: get(options, 'connectionManager', {
-      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),
-      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))
-    }),
-    keychain: keychainConfig,
-    identify: {
-      host: {
-        agentVersion: `js-ipfs/${pkgversion}`
-      }
-    },
-    contentRouters: [],
-    peerRouters: [],
-    peerDiscovery: [],
-    transports: [],
-    streamMuxers: [
-      mplex({
-        maxInboundStreams: 256,
-        maxOutboundStreams: 1024
-      })
-    ],
-    connectionEncryption: [
-      noise()
-    ],
-    relay: {
-      enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),
-      hop: {
-        enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),
-        active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))
-      }
-    },
-    nat: {
-      enabled: !get(config, 'Swarm.DisableNatPortMap', false)
+    /** @type {Libp2pOptions} */
+    const libp2pDefaults = {
+        datastore,
+        peerId: peerId
     }
-  }
-
-  if (get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))) {
-    libp2pOptions.pubsub = getPubsubRouter()
-  }
-
-  if (get(config, 'Routing.Type', 'dhtclient') !== 'none') {
-    libp2pOptions.dht = kadDHT({
-      clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',
-      kBucketSize: get(options, 'dht.kBucketSize', 20),
-      validators: {
-        ipns: ipnsValidator
-      },
-      selectors: {
-        ipns: ipnsSelector
-      }
-    })
-  }
 
-  const boostrapNodes = get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))
+    /** @type {Libp2pOptions} */
+    const libp2pOptions = {
+        addresses: {
+            listen: multiaddrs.map(ma => ma.toString()),
+            announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),
+            noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))
+        },
+        connectionManager: get(options, 'connectionManager', {
+            maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),
+            minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))
+        }),
+        keychain: keychainConfig,
+        identify: {
+            host: {
+                agentVersion: `js-ipfs/${pkgversion}`
+            }
+        },
+        contentRouters: [],
+        peerRouters: [],
+        peerDiscovery: [],
+        transports: get(options, 'transports', get(config, 'transports', [])),
+        streamMuxers: [
+            mplex({
+                maxInboundStreams: 256,
+                maxOutboundStreams: 1024
+            })
+        ],
+        connectionEncryption: [
+            noise()
+        ],
+        relay: {
+            enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),
+            hop: {
+                enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),
+                active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))
+            }
+        },
+        nat: {
+            enabled: !get(config, 'Swarm.DisableNatPortMap', false)
+        }
+    }
 
-  if (boostrapNodes.length > 0) {
-    libp2pOptions.peerDiscovery?.push(
-      bootstrap({
-        list: boostrapNodes
-      })
-    )
-  }
-
-  /** @type {import('libp2p').Libp2pOptions | undefined} */
-  let constructorOptions = get(options, 'libp2p', undefined)
-
-  if (typeof constructorOptions === 'function') {
-    constructorOptions = undefined
-  }
-
-  // Merge defaults with Node.js/browser/other environments options and configuration
-  /** @type {Libp2pOptions} */
-  const libp2pFinalConfig = mergeOptions(
-    libp2pDefaults,
-    getEnvLibp2pOptions(),
-    libp2pOptions,
-    constructorOptions
-  )
-
-  // Set up Delegate Routing based on the presence of Delegates in the config
-  const delegateHosts = get(options, 'config.Addresses.Delegates',
-    get(config, 'Addresses.Delegates', [])
-  )
-
-  if (delegateHosts.length > 0) {
-    // Pick a random delegate host
-    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)]
-    const delegateAddr = multiaddr(delegateString).toOptions()
-    const delegateApiOptions = {
-      host: delegateAddr.host,
-      // port is a string atm, so we need to convert for the check
-      // @ts-expect-error - parseInt(input:string) => number
-      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',
-      port: delegateAddr.port
+    if (get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))) {
+        libp2pOptions.pubsub = getPubsubRouter()
+    }
+
+    if (get(config, 'Routing.Type', 'dhtclient') !== 'none') {
+        libp2pOptions.dht = kadDHT({
+            clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',
+            kBucketSize: get(options, 'dht.kBucketSize', 20),
+            validators: {
+                ipns: ipnsValidator
+            },
+            selectors: {
+                ipns: ipnsSelector
+            }
+        })
+    }
+
+    const boostrapNodes = get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))
+
+    if (boostrapNodes.length > 0) {
+        libp2pOptions.peerDiscovery?.push(
+            bootstrap({
+                list: boostrapNodes
+            })
+        )
     }
 
-    const delegateHttpClient = ipfsHttpClient(delegateApiOptions)
+    /** @type {import('libp2p').Libp2pOptions | undefined} */
+    let constructorOptions = get(options, 'libp2p', undefined)
 
-    libp2pFinalConfig.contentRouters?.push(delegatedContentRouting(delegateHttpClient))
-    libp2pFinalConfig.peerRouters?.push(delegatedPeerRouting(delegateHttpClient))
-  }
+    if (typeof constructorOptions === 'function') {
+        constructorOptions = undefined
+    }
+
+    // Merge defaults with Node.js/browser/other environments options and configuration
+    /** @type {Libp2pOptions} */
+    const libp2pFinalConfig = mergeOptions(
+        libp2pDefaults,
+        getEnvLibp2pOptions(),
+        libp2pOptions,
+        constructorOptions
+    )
+
+    // Set up Delegate Routing based on the presence of Delegates in the config
+    const delegateHosts = get(options, 'config.Addresses.Delegates',
+        get(config, 'Addresses.Delegates', [])
+    )
 
-  // TODO: fixme
-  if (!get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))) {
-    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter(d => {
-      try {
-        if (typeof d === 'function') {
-          // @ts-expect-error not components
-          return d({})[Symbol.toStringTag] !== '@libp2p/mdns'
+    if (delegateHosts.length > 0) {
+        // Pick a random delegate host
+        const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)]
+        const delegateAddr = multiaddr(delegateString).toOptions()
+        const delegateApiOptions = {
+            host: delegateAddr.host,
+            // port is a string atm, so we need to convert for the check
+            // @ts-expect-error - parseInt(input:string) => number
+            protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',
+            port: delegateAddr.port
         }
-      } catch {}
-      return true
-    })
-  }
-
-  if (libp2pFinalConfig.transports == null) {
-    libp2pFinalConfig.transports = []
-  }
-
-  // add WebSocket transport if not overridden by user config
-  if (libp2pFinalConfig.transports.find(t => {
-    try {
-      if (typeof t === 'function') {
-        return t({})[Symbol.toStringTag] === '@libp2p/websockets'
-      }
-    } catch {}
-    return false
-  }) == null) {
-    libp2pFinalConfig.transports.push(webSockets())
-  }
-
-  return libp2pFinalConfig
+
+        const delegateHttpClient = ipfsHttpClient(delegateApiOptions)
+
+        libp2pFinalConfig.contentRouters?.push(delegatedContentRouting(delegateHttpClient))
+        libp2pFinalConfig.peerRouters?.push(delegatedPeerRouting(delegateHttpClient))
+    }
+
+    // TODO: fixme
+    if (!get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))) {
+        libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter(d => {
+            try {
+                if (typeof d === 'function') {
+                    // @ts-expect-error not components
+                    return d({})[Symbol.toStringTag] !== '@libp2p/mdns'
+                }
+            } catch { }
+            return true
+        })
+    }
+
+    if (libp2pFinalConfig.transports == null) {
+        libp2pFinalConfig.transports = []
+    }
+
+    // add WebSocket transport if not overridden by user config
+    if (libp2pFinalConfig.transports.find(t => {
+        try {
+            if (typeof t === 'function') {
+                return t({})[Symbol.toStringTag] === '@libp2p/websockets'
+            }
+        } catch { }
+        return false
+    }) == null) {
+        libp2pFinalConfig.transports.push(webSockets())
+    }
+
+    return libp2pFinalConfig
 }
diff --git a/node_modules/ipfs-core/src/components/network.js b/node_modules/ipfs-core/src/components/network.js
index bed24db..ad30caf 100644
--- a/node_modules/ipfs-core/src/components/network.js
+++ b/node_modules/ipfs-core/src/components/network.js
@@ -28,76 +28,76 @@ import { BlockStorage } from '../block-storage.js'
  */
 
 export class Network {
-  /**
-   * @param {PeerId} peerId
-   * @param {libp2p} libp2p
-   * @param {Bitswap} bitswap
-   * @param {Repo} repo
-   * @param {BlockStorage} blockstore
-   */
-  constructor (peerId, libp2p, bitswap, repo, blockstore) {
-    this.peerId = peerId
-    this.libp2p = libp2p
-    this.bitswap = bitswap
-    this.repo = repo
-    this.blockstore = blockstore
-  }
-
-  /**
-   * @param {Options} options
-   */
-  static async start ({ peerId, repo, print, hashers, options }) {
-    // Need to ensure that repo is open as it could have been closed between
-    // `init` and `start`.
-    if (repo.closed) {
-      await repo.open()
+    /**
+     * @param {PeerId} peerId
+     * @param {libp2p} libp2p
+     * @param {Bitswap} bitswap
+     * @param {Repo} repo
+     * @param {BlockStorage} blockstore
+     */
+    constructor(peerId, libp2p, bitswap, repo, blockstore) {
+        this.peerId = peerId
+        this.libp2p = libp2p
+        this.bitswap = bitswap
+        this.repo = repo
+        this.blockstore = blockstore
     }
 
-    /** @type {IPFSConfig} */
-    const config = await repo.config.getAll()
-
-    const libp2p = await createLibp2p({
-      options,
-      repo,
-      peerId,
-      multiaddrs: readAddrs(peerId, config),
-      config,
-      keychainConfig: undefined
-    })
+    /**
+     * @param {Options} options
+     */
+    static async start({ peerId, repo, print, hashers, options }) {
+        // Need to ensure that repo is open as it could have been closed between
+        // `init` and `start`.
+        if (repo.closed) {
+            await repo.open()
+        }
+
+        /** @type {IPFSConfig} */
+        const config = await repo.config.getAll()
+
+        const libp2p = typeof options.libp2p === 'function' ? await options.libp2p({ peerId }) : await createLibp2p({
+            options: options.libp2p,
+            repo,
+            peerId,
+            multiaddrs: readAddrs(peerId, config),
+            config,
+            keychainConfig: undefined
+        })
+
+        await libp2p.start()
+
+        for (const ma of libp2p.getMultiaddrs()) {
+            print(`Swarm listening on ${ma.toString()}`)
+        }
+
+        const bitswap = createBitswap(libp2p, repo.blocks, {
+            statsEnabled: true,
+            hashLoader: hashers,
+            maxInboundStreams: 1024,
+            maxOutboundStreams: 1024
+        })
+        await bitswap.start()
+
+        const blockstore = new BlockStorage(repo.blocks, bitswap)
+        repo.blocks = blockstore
+        // @ts-expect-error private field
+        repo.pins.blockstore = blockstore
+
+        return new Network(peerId, libp2p, bitswap, repo, blockstore)
+    }
 
-    await libp2p.start()
+    /**
+     * @param {Network} network
+     */
+    static async stop(network) {
+        network.repo.blocks = network.blockstore.unwrap()
+        // @ts-expect-error private field
+        network.repo.pins.blockstore = network.blockstore.unwrap()
 
-    for (const ma of libp2p.getMultiaddrs()) {
-      print(`Swarm listening on ${ma.toString()}`)
+        await network.bitswap.stop()
+        await network.libp2p.stop()
     }
-
-    const bitswap = createBitswap(libp2p, repo.blocks, {
-      statsEnabled: true,
-      hashLoader: hashers,
-      maxInboundStreams: 1024,
-      maxOutboundStreams: 1024
-    })
-    await bitswap.start()
-
-    const blockstore = new BlockStorage(repo.blocks, bitswap)
-    repo.blocks = blockstore
-    // @ts-expect-error private field
-    repo.pins.blockstore = blockstore
-
-    return new Network(peerId, libp2p, bitswap, repo, blockstore)
-  }
-
-  /**
-   * @param {Network} network
-   */
-  static async stop (network) {
-    network.repo.blocks = network.blockstore.unwrap()
-    // @ts-expect-error private field
-    network.repo.pins.blockstore = network.blockstore.unwrap()
-
-    await network.bitswap.stop()
-    await network.libp2p.stop()
-  }
 }
 
 /**
@@ -105,31 +105,31 @@ export class Network {
  * @param {IPFSConfig} config
  */
 const readAddrs = (peerId, config) => {
-  const peerIdStr = peerId.toString()
-  /** @type {Multiaddr[]} */
-  const addrs = []
-  const swarm = (config.Addresses && config.Addresses.Swarm) || []
-  for (const addr of swarm) {
-    let ma = multiaddr(addr)
-
-    // Temporary error for users migrating using websocket-star multiaddrs for listenning on libp2p
-    // websocket-star support was removed from ipfs and libp2p
-    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
-      throw errCode(new Error('websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779'), 'ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED')
+    const peerIdStr = peerId.toString()
+    /** @type {Multiaddr[]} */
+    const addrs = []
+    const swarm = (config.Addresses && config.Addresses.Swarm) || []
+    for (const addr of swarm) {
+        let ma = multiaddr(addr)
+
+        // Temporary error for users migrating using websocket-star multiaddrs for listenning on libp2p
+        // websocket-star support was removed from ipfs and libp2p
+        if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
+            throw errCode(new Error('websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779'), 'ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED')
+        }
+
+        // multiaddrs that go via a signalling server or other intermediary (e.g. stardust,
+        // webrtc-star) can have the intermediary's peer ID in the address, so append our
+        // peer ID to the end of it
+        const maId = ma.getPeerId()
+        if (maId && maId !== peerIdStr) {
+            ma = ma.encapsulate(`/p2p/${peerIdStr}`)
+        }
+
+        addrs.push(ma)
     }
 
-    // multiaddrs that go via a signalling server or other intermediary (e.g. stardust,
-    // webrtc-star) can have the intermediary's peer ID in the address, so append our
-    // peer ID to the end of it
-    const maId = ma.getPeerId()
-    if (maId && maId !== peerIdStr) {
-      ma = ma.encapsulate(`/p2p/${peerIdStr}`)
-    }
-
-    addrs.push(ma)
-  }
-
-  return addrs
+    return addrs
 }
 
 const WEBSOCKET_STAR_PROTO_CODE = 479
diff --git a/node_modules/ipfs-core/src/components/storage.js b/node_modules/ipfs-core/src/components/storage.js
index 416e7b0..e19e312 100644
--- a/node_modules/ipfs-core/src/components/storage.js
+++ b/node_modules/ipfs-core/src/components/storage.js
@@ -30,45 +30,45 @@ const log = logger('ipfs:components:peer:storage')
  */
 
 export class Storage {
-  /**
-   * @private
-   * @param {PeerId} peerId
-   * @param {Keychain} keychain
-   * @param {IPFSRepo} repo
-   * @param {Print} print
-   * @param {boolean} isNew
-   */
-  constructor (peerId, keychain, repo, print, isNew) {
-    this.print = print
-    this.peerId = peerId
-    this.keychain = keychain
-    this.repo = repo
-    this.print = print
-    this.isNew = isNew
-  }
-
-  /**
-   * @param {Print} print
-   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs
-   * @param {IPFSOptions} options
-   */
-  static async start (print, codecs, options) {
-    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options
-
-    const repo = (typeof inputRepo === 'string' || inputRepo == null)
-      ? createRepo(print, codecs, {
-        path: inputRepo,
-        autoMigrate: repoAutoMigrate,
-        onMigrationProgress: onMigrationProgress
-      })
-      : inputRepo
-
-    const { peerId, keychain, isNew } = await loadRepo(print, repo, options)
-
-    // TODO: throw error?
-    // @ts-expect-error On start, keychain will always be available
-    return new Storage(peerId, keychain, repo, print, isNew)
-  }
+    /**
+     * @private
+     * @param {PeerId} peerId
+     * @param {Keychain} keychain
+     * @param {IPFSRepo} repo
+     * @param {Print} print
+     * @param {boolean} isNew
+     */
+    constructor(peerId, keychain, repo, print, isNew) {
+        this.print = print
+        this.peerId = peerId
+        this.keychain = keychain
+        this.repo = repo
+        this.print = print
+        this.isNew = isNew
+    }
+
+    /**
+     * @param {Print} print
+     * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs
+     * @param {IPFSOptions} options
+     */
+    static async start(print, codecs, options) {
+        const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options
+
+        const repo = (typeof inputRepo === 'string' || inputRepo == null)
+            ? createRepo(print, codecs, {
+                path: inputRepo,
+                autoMigrate: repoAutoMigrate,
+                onMigrationProgress: onMigrationProgress
+            })
+            : inputRepo
+
+        const { peerId, keychain, isNew } = await loadRepo(print, repo, options)
+
+        // TODO: throw error?
+        // @ts-expect-error On start, keychain will always be available
+        return new Storage(peerId, keychain, repo, print, isNew)
+    }
 }
 
 /**
@@ -77,25 +77,25 @@ export class Storage {
  * @param {IPFSOptions} options
  */
 const loadRepo = async (print, repo, options) => {
-  if (!repo.closed) {
-    return { ...await configureRepo(repo, options), isNew: false }
-  }
+    if (!repo.closed) {
+        return { ...await configureRepo(repo, options), isNew: false }
+    }
 
-  try {
-    await repo.open()
+    try {
+        await repo.open()
 
-    return { ...await configureRepo(repo, options), isNew: false }
-  } catch (/** @type {any} */ err) {
-    if (err.code !== ERR_REPO_NOT_INITIALIZED) {
-      throw err
-    }
+        return { ...await configureRepo(repo, options), isNew: false }
+    } catch (/** @type {any} */ err) {
+        if (err.code !== ERR_REPO_NOT_INITIALIZED) {
+            throw err
+        }
 
-    if (options.init && options.init.allowNew === false) {
-      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it')
-    }
+        if (options.init && options.init.allowNew === false) {
+            throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it')
+        }
 
-    return { ...await initRepo(print, repo, options), isNew: true }
-  }
+        return { ...await initRepo(print, repo, options), isNew: true }
+    }
 }
 
 /**
@@ -105,70 +105,70 @@ const loadRepo = async (print, repo, options) => {
  * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}
  */
 const initRepo = async (print, repo, options) => {
-  const initOptions = options.init || {}
+    const initOptions = options.init || {}
+
+    // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)
+    const exists = await repo.exists()
+    log('repo exists?', exists)
 
-  // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)
-  const exists = await repo.exists()
-  log('repo exists?', exists)
+    if (exists === true) {
+        throw new Error('repo already exists')
+    }
 
-  if (exists === true) {
-    throw new Error('repo already exists')
-  }
+    // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.
+    const peerId = initOptions.privateKey
+        ? await decodePeerId(initOptions.privateKey)
+        : await initPeerId(print, initOptions)
 
-  // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.
-  const peerId = initOptions.privateKey
-    ? await decodePeerId(initOptions.privateKey)
-    : await initPeerId(print, initOptions)
+    const identity = peerIdToIdentity(peerId)
 
-  const identity = peerIdToIdentity(peerId)
+    log('peer identity: %s', identity.PeerID)
 
-  log('peer identity: %s', identity.PeerID)
+    // 3. Init new repo with provided `.config` and restored / initialized `peerId`
+    const config = {
+        ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),
+        Identity: identity
+    }
+    await repo.init(config)
 
-  // 3. Init new repo with provided `.config` and restored / initialized `peerId`
-  const config = {
-    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),
-    Identity: identity
-  }
-  await repo.init(config)
+    // 4. Open initialized repo.
+    await repo.open()
 
-  // 4. Open initialized repo.
-  await repo.open()
+    log('repo opened')
 
-  log('repo opened')
+    /** @type {import('./libp2p').KeychainConfig} */
+    const keychainConfig = {
+        pass: options.pass
+    }
 
-  /** @type {import('./libp2p').KeychainConfig} */
-  const keychainConfig = {
-    pass: options.pass
-  }
+    try {
+        keychainConfig.dek = await repo.config.get('Keychain.DEK')
+    } catch (/** @type {any} */ err) {
+        if (err.code !== 'ERR_NOT_FOUND') {
+            throw err
+        }
+    }
 
-  try {
-    keychainConfig.dek = await repo.config.get('Keychain.DEK')
-  } catch (/** @type {any} */ err) {
-    if (err.code !== 'ERR_NOT_FOUND') {
-      throw err
+    // Create libp2p for Keychain creation
+    const libp2p = typeof options.libp2p === 'function' ? await options.libp2p({ peerId }) : await createLibp2p({
+        options: options.libp2p,
+        multiaddrs: undefined,
+        peerId,
+        repo,
+        config,
+        keychainConfig
+    })
+
+    if (!(await repo.datastore.has(new Key('/info/self')))) {
+        await libp2p.keychain.importPeer('self', peerId)
     }
-  }
-
-  // Create libp2p for Keychain creation
-  const libp2p = await createLibp2p({
-    options: undefined,
-    multiaddrs: undefined,
-    peerId,
-    repo,
-    config,
-    keychainConfig
-  })
-
-  if (!(await repo.datastore.has(new Key('/info/self')))) {
-    await libp2p.keychain.importPeer('self', peerId)
-  }
-
-  await repo.config.set('Keychain', {
-    // @ts-expect-error private field
-    DEK: libp2p.keychain.init.dek
-  })
-
-  return { peerId, keychain: libp2p.keychain }
+
+    await repo.config.set('Keychain', {
+        // @ts-expect-error private field
+        DEK: libp2p.keychain.init.dek
+    })
+
+    return { peerId, keychain: libp2p.keychain }
 }
 
 /**
@@ -179,14 +179,14 @@ const initRepo = async (print, repo, options) => {
  * @returns {Promise<PeerId>}
  */
 const decodePeerId = async (peerId) => {
-  log('using user-supplied private-key')
-  if (isPeerId(peerId)) {
-    return peerId
-  }
-
-  const rawPrivateKey = uint8ArrayFromString(peerId, 'base64pad')
-  const key = await unmarshalPrivateKey(rawPrivateKey)
-  return await peerIdFromKeys(key.public.bytes, key.bytes)
+    log('using user-supplied private-key')
+    if (isPeerId(peerId)) {
+        return peerId
+    }
+
+    const rawPrivateKey = uint8ArrayFromString(peerId, 'base64pad')
+    const key = await unmarshalPrivateKey(rawPrivateKey)
+    return await peerIdFromKeys(key.public.bytes, key.bytes)
 }
 
 /**
@@ -199,33 +199,33 @@ const decodePeerId = async (peerId) => {
  * @returns {Promise<PeerId>}
  */
 const initPeerId = (print, { algorithm = 'Ed25519', bits = 2048 }) => {
-  // Generate peer identity keypair + transform to desired format + add to config.
-  print('generating %s keypair...', algorithm)
+    // Generate peer identity keypair + transform to desired format + add to config.
+    print('generating %s keypair...', algorithm)
 
-  if (algorithm === 'Ed25519') {
-    return createEd25519PeerId()
-  }
+    if (algorithm === 'Ed25519') {
+        return createEd25519PeerId()
+    }
 
-  if (algorithm === 'RSA') {
-    return createRSAPeerId({ bits })
-  }
+    if (algorithm === 'RSA') {
+        return createRSAPeerId({ bits })
+    }
 
-  throw errCode(new Error('Unknown PeerId algorithm'), 'ERR_UNKNOWN_PEER_ID_ALGORITHM')
+    throw errCode(new Error('Unknown PeerId algorithm'), 'ERR_UNKNOWN_PEER_ID_ALGORITHM')
 }
 
 /**
  * @param {PeerId} peerId
  */
 const peerIdToIdentity = (peerId) => {
-  if (peerId.privateKey == null) {
-    throw errCode(new Error('Private key missing'), 'ERR_MISSING_PRIVATE_KEY')
-  }
-
-  return {
-    PeerID: peerId.toString(),
-    /** @type {string} */
-    PrivKey: uint8ArrayToString(peerId.privateKey, 'base64pad')
-  }
+    if (peerId.privateKey == null) {
+        throw errCode(new Error('Private key missing'), 'ERR_MISSING_PRIVATE_KEY')
+    }
+
+    return {
+        PeerID: peerId.toString(),
+        /** @type {string} */
+        PrivKey: uint8ArrayToString(peerId.privateKey, 'base64pad')
+    }
 }
 
 /**
@@ -236,36 +236,36 @@ const peerIdToIdentity = (peerId) => {
  * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}
  */
 const configureRepo = async (repo, options) => {
-  const config = options.config
-  const profiles = (options.init && options.init.profiles) || []
-  const pass = options.pass
-  const original = await repo.config.getAll()
-  const changed = mergeConfigs(applyProfiles(original, profiles), config)
-
-  if (original !== changed) {
-    await repo.config.replace(changed)
-  }
-
-  if (!changed.Identity || !changed.Identity.PrivKey) {
-    throw new NotInitializedError('No private key was found in the config, please intialize the repo')
-  }
-
-  const buf = uint8ArrayFromString(changed.Identity.PrivKey, 'base64pad')
-  const key = await unmarshalPrivateKey(buf)
-  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes)
-  const libp2p = await createLibp2p({
-    options: undefined,
-    multiaddrs: undefined,
-    peerId,
-    repo,
-    config: changed,
-    keychainConfig: {
-      pass,
-      ...changed.Keychain
+    const config = options.config
+    const profiles = (options.init && options.init.profiles) || []
+    const pass = options.pass
+    const original = await repo.config.getAll()
+    const changed = mergeConfigs(applyProfiles(original, profiles), config)
+
+    if (original !== changed) {
+        await repo.config.replace(changed)
     }
-  })
 
-  return { peerId, keychain: libp2p.keychain }
+    if (!changed.Identity || !changed.Identity.PrivKey) {
+        throw new NotInitializedError('No private key was found in the config, please intialize the repo')
+    }
+
+    const buf = uint8ArrayFromString(changed.Identity.PrivKey, 'base64pad')
+    const key = await unmarshalPrivateKey(buf)
+    const peerId = await peerIdFromKeys(key.public.bytes, key.bytes)
+    const libp2p = typeof options.libp2p === 'function' ? await options.libp2p({ peerId }) : await createLibp2p({
+        options: options.libp2p,
+        multiaddrs: undefined,
+        peerId,
+        repo,
+        config: changed,
+        keychainConfig: {
+            pass,
+            ...changed.Keychain
+        }
+    })
+
+    return { peerId, keychain: libp2p.keychain }
 }
 
 /**
@@ -273,7 +273,7 @@ const configureRepo = async (repo, options) => {
  * @param {Partial<IPFSConfig>} [changes]
  */
 const mergeConfigs = (config, changes) =>
-  changes ? mergeOptions(config, changes) : config
+    changes ? mergeOptions(config, changes) : config
 
 /**
  * Apply profiles (e.g. ['server', 'lowpower']) to config
@@ -282,12 +282,12 @@ const mergeConfigs = (config, changes) =>
  * @param {string[]} [profiles]
  */
 const applyProfiles = (config, profiles) => {
-  return (profiles || []).reduce((config, name) => {
-    const profile = configProfiles[name]
-    if (!profile) {
-      throw new Error(`Could not find profile with name '${name}'`)
-    }
-    log('applying profile %s', name)
-    return profile.transform(config)
-  }, config)
+    return (profiles || []).reduce((config, name) => {
+        const profile = configProfiles[name]
+        if (!profile) {
+            throw new Error(`Could not find profile with name '${name}'`)
+        }
+        log('applying profile %s', name)
+        return profile.transform(config)
+    }, config)
 }
diff --git a/node_modules/ipfs-core/src/utils/service.js b/node_modules/ipfs-core/src/utils/service.js
index e966592..c51897c 100644
--- a/node_modules/ipfs-core/src/utils/service.js
+++ b/node_modules/ipfs-core/src/utils/service.js
@@ -39,199 +39,199 @@ import { withTimeout } from '../utils.js'
  *
  */
 export class Service {
-  /**
-   * Takes `activation` function that takes `options` and (async) returns
-   * an implementation.
-   *
-   * @template {(options:any) => Await<any>} T
-   *
-   * @param {object} config
-   * @param {T} config.start
-   * @param {(state:State<T>) => Await<void>} [config.stop]
-   * @returns {Service<Parameters<T>[0], State<T>>}
-   */
-  static create ({ start, stop }) {
-    return new Service(start, stop)
-  }
+    /**
+     * Takes `activation` function that takes `options` and (async) returns
+     * an implementation.
+     *
+     * @template {(options:any) => Await<any>} T
+     *
+     * @param {object} config
+     * @param {T} config.start
+     * @param {(state:State<T>) => Await<void>} [config.stop]
+     * @returns {Service<Parameters<T>[0], State<T>>}
+     */
+    static create({ start, stop }) {
+        return new Service(start, stop)
+    }
 
-  /**
-   * Starts the service (by running actiavtion function). Will (async) throw
-   * unless service is stopped.
-   *
-   * @template Options, T
-   * @param {Service<Options, T>} service
-   * @param {Options} options
-   * @returns {Promise<T>}
-   */
-  static async start (service, options) {
-    const { state, activate } = service
-    switch (state.status) {
-      // If service is in 'stopped' state we activate and transition to
-      // to 'pending' state. Once activation is complete transition state to
-      // 'started' state.
-      // Note: This is the only code that does state transitions from
-      // - stopped
-      // - started
-      // Which ensures no race conditions can occur.
-      case 'stopped': {
-        try {
-          const promise = activate(options)
-          service.state = { status: 'starting', ready: promise }
-          // Note: MUST await after state transition above otherwise race
-          // condition may occur.
-          const result = await promise
-          service.state = { status: 'started', value: result }
-          return result
-        // If failed to start, transiton from 'starting' to 'stopped'
-        // state.
-        } catch (/** @type {any} */ error) {
-          service.state = { status: 'stopped' }
-          throw error
+    /**
+     * Starts the service (by running actiavtion function). Will (async) throw
+     * unless service is stopped.
+     *
+     * @template Options, T
+     * @param {Service<Options, T>} service
+     * @param {Options} options
+     * @returns {Promise<T>}
+     */
+    static async start(service, options) {
+        const { state, activate } = service
+        switch (state.status) {
+            // If service is in 'stopped' state we activate and transition to
+            // to 'pending' state. Once activation is complete transition state to
+            // 'started' state.
+            // Note: This is the only code that does state transitions from
+            // - stopped
+            // - started
+            // Which ensures no race conditions can occur.
+            case 'stopped': {
+                try {
+                    const promise = activate(options)
+                    service.state = { status: 'starting', ready: promise }
+                    // Note: MUST await after state transition above otherwise race
+                    // condition may occur.
+                    const result = await promise
+                    service.state = { status: 'started', value: result }
+                    return result
+                    // If failed to start, transiton from 'starting' to 'stopped'
+                    // state.
+                } catch (/** @type {any} */ error) {
+                    service.state = { status: 'stopped' }
+                    throw error
+                }
+            }
+            case 'starting': {
+                throw new AlreadyStartingError()
+            }
+            case 'started': {
+                throw new AlreadyStartedError()
+            }
+            // If service is stopping we just wait for that to complete
+            // and try again.
+            case 'stopping': {
+                await state.ready
+                return await Service.start(service, options)
+            }
+            default: {
+                return Service.panic(service)
+            }
         }
-      }
-      case 'starting': {
-        throw new AlreadyStartingError()
-      }
-      case 'started': {
-        throw new AlreadyStartedError()
-      }
-      // If service is stopping we just wait for that to complete
-      // and try again.
-      case 'stopping': {
-        await state.ready
-        return await Service.start(service, options)
-      }
-      default: {
-        return Service.panic(service)
-      }
     }
-  }
 
-  /**
-   * Stops the service by executing deactivation. If service is stopped
-   * or is stopping this is noop. If service is starting up when called
-   * it will await for start to complete and then retry stop afterwards.
-   * This may (async) throw if `deactivate` does.
-   *
-   * @template T
-   * @param {Service<any, T>} service
-   * @returns {Promise<void>}
-   */
-  static async stop (service) {
-    const { state, deactivate } = service
-    switch (state.status) {
-      // If stopped there's nothing to do.
-      case 'stopped': {
-        break
-      }
-      // If service is starting we await for it to complete
-      // and try again. That way
-      case 'starting': {
-        // We do not want to error stop if start failed.
-        try { await state.ready } catch (/** @type {any} */ _) {}
-        return await Service.stop(service)
-      }
-      // if service is stopping we just await for it to complete.
-      case 'stopping': {
-        return await state.ready
-      }
-      case 'started': {
-        if (deactivate) {
-          await deactivate(state.value)
+    /**
+     * Stops the service by executing deactivation. If service is stopped
+     * or is stopping this is noop. If service is starting up when called
+     * it will await for start to complete and then retry stop afterwards.
+     * This may (async) throw if `deactivate` does.
+     *
+     * @template T
+     * @param {Service<any, T>} service
+     * @returns {Promise<void>}
+     */
+    static async stop(service) {
+        const { state, deactivate } = service
+        switch (state.status) {
+            // If stopped there's nothing to do.
+            case 'stopped': {
+                break
+            }
+            // If service is starting we await for it to complete
+            // and try again. That way
+            case 'starting': {
+                // We do not want to error stop if start failed.
+                try { await state.ready } catch (/** @type {any} */ _) { }
+                return await Service.stop(service)
+            }
+            // if service is stopping we just await for it to complete.
+            case 'stopping': {
+                return await state.ready
+            }
+            case 'started': {
+                if (deactivate) {
+                    await deactivate(state.value)
+                }
+                service.state = { status: 'stopped' }
+                break
+            }
+            default: {
+                Service.panic(state)
+            }
         }
-        service.state = { status: 'stopped' }
-        break
-      }
-      default: {
-        Service.panic(state)
-      }
     }
-  }
 
-  /**
-   * @template T
-   * @param {Service<any, T>} service
-   * @returns {T|null}
-   */
-  static try ({ state }) {
-    switch (state.status) {
-      case 'started':
-        return state.value
-      default:
-        return null
+    /**
+     * @template T
+     * @param {Service<any, T>} service
+     * @returns {T|null}
+     */
+    static try({ state }) {
+        switch (state.status) {
+            case 'started':
+                return state.value
+            default:
+                return null
+        }
     }
-  }
 
-  /**
-   * Unwraps state and returns underlying value. If state is in idle state it
-   * will throw an error. If state is pending it will wait and return the
-   * result or throw on failure. If state is ready returns result.
-   *
-   * @template T
-   * @param {Service<any, T>} service
-   * @param {AbortOptions} [options]
-   * @returns {Promise<T>}
-   */
-  static async use ({ state }, options) {
-    switch (state.status) {
-      case 'started':
-        return state.value
-      case 'starting':
-        return await withTimeout(state.ready, options)
-      default:
-        throw new NotStartedError()
+    /**
+     * Unwraps state and returns underlying value. If state is in idle state it
+     * will throw an error. If state is pending it will wait and return the
+     * result or throw on failure. If state is ready returns result.
+     *
+     * @template T
+     * @param {Service<any, T>} service
+     * @param {AbortOptions} [options]
+     * @returns {Promise<T>}
+     */
+    static async use({ state }, options) {
+        switch (state.status) {
+            case 'started':
+                return state.value
+            case 'starting':
+                return await withTimeout(state.ready, options)
+            default:
+                throw new NotStartedError()
+        }
     }
-  }
 
-  // eslint-disable-next-line jsdoc/require-returns-check
-  /**
-   * @private
-   * @param {Service<any, any>} service
-   * @returns {never}
-   */
-  static panic ({ state }) {
-    const status = JSON.stringify({ status: state.status })
-    throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`)
-  }
-
-  /**
-   * Takes `activation` function that takes `options` and (async) returns
-   * an implementation.
-   *
-   * @private
-   * @param {(options:Options) => Await<T>} activate
-   * @param {(state:T) => Await<void>} [deactivate]
-   */
-  constructor (activate, deactivate) {
-    this.activate = activate
-    this.deactivate = deactivate
+    // eslint-disable-next-line jsdoc/require-returns-check
+    /**
+     * @private
+     * @param {Service<any, any>} service
+     * @returns {never}
+     */
+    static panic({ state }) {
+        const status = JSON.stringify({ status: state.status })
+        throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`)
+    }
 
     /**
-     * A state machine for this service.
+     * Takes `activation` function that takes `options` and (async) returns
+     * an implementation.
      *
      * @private
-     * @type {ServiceState<T>}
+     * @param {(options:Options) => Await<T>} activate
+     * @param {(state:T) => Await<void>} [deactivate]
      */
-    this.state = { status: 'stopped' }
-  }
+    constructor(activate, deactivate) {
+        this.activate = activate
+        this.deactivate = deactivate
+
+        /**
+         * A state machine for this service.
+         *
+         * @private
+         * @type {ServiceState<T>}
+         */
+        this.state = { status: 'stopped' }
+    }
 
-  /**
-   * Allows you to asynchronously obtain service implementation. If service
-   * is starting it will await for completion. If service is stopped or stopping
-   * this will (async) throw exception. This allows components that need to use
-   * this service convenient API to do it.
-   *
-   * @param {AbortOptions} [options] - Abort options.
-   * @returns {Promise<T>}
-   */
-  async use (options) {
-    return await Service.use(this, options)
-  }
+    /**
+     * Allows you to asynchronously obtain service implementation. If service
+     * is starting it will await for completion. If service is stopped or stopping
+     * this will (async) throw exception. This allows components that need to use
+     * this service convenient API to do it.
+     *
+     * @param {AbortOptions} [options] - Abort options.
+     * @returns {Promise<T>}
+     */
+    async use(options) {
+        return await Service.use(this, options)
+    }
 
-  /**
-   * @returns {T|null}
-   */
-  try () {
-    return Service.try(this)
-  }
+    /**
+     * @returns {T|null}
+     */
+    try() {
+        return Service.try(this)
+    }
 }
